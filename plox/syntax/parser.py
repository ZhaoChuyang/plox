from typing import List
from plox.error import error, PLoxRuntimeError, runtime_error
from plox.lexer.token import *
from plox.syntax.expr import *
from plox.syntax import stmt


class Parser:
    def __init__(self):
        """
        There two kinds of things to parse, statement (plox.syntax.stmt) or expression (plox.syntax.expr).
        For statement, the entrance method is statement(), the return value being Stmt, 
        whereas for expression, the entrance method is expression(), the return value being Expr.
        They are both used by the interpreter for executing.

        Args:
            tokens: lexical tokens generated by the lexical scanner.
        
        Attributes:
            current: pointer point to the next token waiting to be parsed.
        """
        self.tokens = None
        self.current = 0

    def parse(self, tokens: List[Token]):
        self.tokens = tokens
        
        statements = []
        while not self.is_end():
            statements.append(self.declaration())
        
        return statements

    def peek(self):
        return self.tokens[self.current]

    def is_end(self):
        return isinstance(self.peek(), EOF)
    
    def previous(self):
        return self.tokens[self.current-1]

    def advance(self):
        if not self.is_end(): self.current += 1
        return self.previous()

    def check(self, token_type: Token):
        """
        Check whether the current token is an instance of token_type.
        Return false if currently is at the end. 
        """
        if self.is_end(): return False
        return isinstance(self.peek(), token_type)

    def match(self, *token_types):
        for token_type in token_types:
            if self.check(token_type):
                self.advance()
                return True
        return False

    def consume(self, token_type: Token, message: str):
        if self.check(token_type):
            return self.advance()

        error(self.peek().line, message)
        exit(1)

    def declaration(self):
        """
        Syntax:
            declaration := funDecl | varDecl | statement | classDecl;
            funDecl := "fun" function ;
        """
        try:
            if self.match(FUN):
                return self.function("function")
            if self.match(VAR):
                return self.var_declaration()
            if self.match(CLASS):
                return self.class_declaration()
            
            return self.statement()
        except:
            pass

    def class_declaration(self):
        """
        Syntax:
            classDecl := "class" IDENTIFIER ( "<" IDENTIFIER )? "{" function* "}" ;
        """
        name = self.consume(IDENTIFIER, "Expect class name.")

        superclass = None
        if self.match(LESS):
            self.consume(IDENTIFIER, "Expect super class name.")
            superclass = Variable(self.previous())

        self.consume(LEFT_BRACE, "Expect '{' before class body.")

        methods = []
        while not self.check(RIGHT_BRACE) and not self.is_end():
            methods.append(self.function("method"))
        
        self.consume(RIGHT_BRACE, "Expect '}' after class body.")
        
        return stmt.Class(name, superclass, methods)
        
    def var_declaration(self):
        """
        Syntax:
            varDecl := "var" IDENTIFIER ( "=" expression)? ";" ;
        """
        name = self.consume(IDENTIFIER, "Expect variable name.")
        initializer = None

        if self.match(EQUAL):
            initializer = self.expression()
        
        self.consume(SEMICOLON, "Expect ';' after variable declaration.")
        return stmt.Var(name, initializer)

    def if_statement(self):
        """
        Syntax:
            ifStmt := "if" "(" expression ")" statement ( "else" statement )?
        """
        self.consume(LEFT_PAREN,"Expect '(' after 'if'.")
        condition = self.expression()
        self.consume(RIGHT_PAREN,"Expect ')' after if condition.")
        then_branch = self.statement()
        
        else_branch = None
        if self.match(ELSE):
            else_branch = self.statement()
        
        return stmt.If(condition, then_branch, else_branch)

    def statement(self) -> stmt.Stmt:
        """
        Syntax:
            statement := exprStmt 
                         | printStmt 
                         | forStmt 
                         | ifStmt
                         | returnStmt
                         | whileStmt
                         | blockStmt ;
        """
        if self.match(FOR):
            return self.for_statement()
        if self.match(IF):
            return self.if_statement()
        if self.match(PRINT):
            return self.print_statement()
        if self.match(RETURN):
            return self.return_statement()
        if self.match(WHILE):
            return self.while_statement()
        if self.match(LEFT_BRACE):
            return stmt.Block(self.block())
        return self.expression_statement()

    def block(self):
        """
        Syntax:
            block := "{" declaration* "}" ;
        """
        statements = []

        while not self.check(RIGHT_BRACE) and not self.is_end():
            statements.append(self.declaration())
        
        self.consume(RIGHT_BRACE, "Expect '}' after block.")
        return statements
        
    def while_statement(self):
        """
        Syntax:
            whileStmt := "while" "(" expression ")" statement ;
        """
        self.consume(LEFT_PAREN, "Expect '(' after 'while'.")
        condition = self.expression()
        self.consume(RIGHT_PAREN, "Expect ')' after condition.")
        body = self.statement()
        return stmt.While(condition, body)
    
    def for_statement(self):
        """
        Syntax:
            forStmt := "for" "(" ( varDecl | exprStmt | ";" )
                       expression? ";"
                       expression? ")" statement ;
        """
        self.consume(LEFT_PAREN, "Expect '(' after 'for'.")
        
        initializer = None
        if self.match(SEMICOLON):
            pass
        elif self.match(VAR):
            initializer = self.var_declaration()
        else:
            initializer = self.expression_statement()
        
        condition = None
        if not self.check(SEMICOLON):
            condition = self.expression()

        self.consume(SEMICOLON, "Expect ';' after loop condition.")

        increment = None
        if not self.check(RIGHT_PAREN):
            increment = self.expression()
        self.consume(RIGHT_PAREN, "Expect ')' after for clauses.")

        body = self.statement()

        """
        desugaring: turn for loop into while loop
        """
        if increment is not None:
            # increment is parsed with expression(), whose return value is a Expr instance.
            # you need to wrap it in Stmt for executing.
            body = [body, stmt.Expression(increment)]
            body = stmt.Block(body)

        if condition is None:
            condition = Literal(True)
        body = stmt.While(condition, body)

        if initializer is not None:
            body = stmt.Block([initializer, body])

        return body

    def print_statement(self):
        """
        printStmt := "print" expression ";" ;
        """
        value = self.expression()
        self.consume(SEMICOLON, "Expect ; after expression.")
        return stmt.Print(value)

    def return_statement(self):
        """
        Syntax:
            "return" expression? ";" ;
        """
        keyword = self.previous()
        value = None
        if not self.check(SEMICOLON):
            value = self.expression()
        
        self.consume(SEMICOLON, "Expect ';' after return value.")
        return stmt.Return(keyword, value)

    def expression_statement(self):
        expr = self.expression()
        self.consume(SEMICOLON, "Expect ; after expression.")
        return stmt.Expression(expr)

    def function(self, kind: str) -> stmt.Function:
        """
        Syntax:
            function := IDENTIFIER "(" parameters? ")" block ;

        Args:
            kind (str): "function" for pure function and "method" for class function.
        """
        name = self.consume(IDENTIFIER, f"Expect {kind} name.")
        self.consume(LEFT_PAREN, f"Expect '(' after {kind} name.")
        parameters = []
        if not self.check(RIGHT_PAREN):
            while True:
                if len(parameters) >= 255:
                    error(self.peek(), "Can't have more than 255 parameters.")
                parameters.append(self.consume(IDENTIFIER, "Expect parameter name."))
                if not self.match(COMMA):
                    break
        
        self.consume(RIGHT_PAREN, "Expect ')' after parameters.")
        self.consume(LEFT_BRACE, "Expect '{' before %s body." % kind)
        body = self.block()
        return stmt.Function(name, parameters, body)

    def expression(self) -> Expr:
        """
        Syntax:
            expression := assignment ;
        """
        return self.assignment()

    def assignment(self):
        """
        Syntax:
            assignment := (call ".")? IDENTIFIER "=" assigment 
                          | logic_or ;
        """
        # NOTE: `(call ".")? IDENTIFIER` can be derived with logic_or syntax
        # To determine if the assignment statement is an expression or assignment,
        # we use the rule of logic_or() to parse any expression on the left side.
        # After we parsed the l-value, we examine if the next token is EQUAL, if so
        # the expression after EQUAL is the r-value binded to the l-value.
        expr = self.logic_or()

        if self.match(EQUAL):
            # NOTE: `equals` is the token EQUAL and `value` is an Expr derived by assignment()
            equals = self.previous()
            value = self.assignment()

            if isinstance(expr, Variable):
                name = expr.name
                return Assign(name, value)
            elif isinstance(expr, Get):
                get = expr
                return Set(get.object, get.name, value)
            else:
                error(equals.line, "Invalid Assignment Target.")
        
        return expr
        

    def logic_or(self):
        """
        Syntax:
            logic_or := logic_and ( "or" logic_and )* ;
        """
        expr = self.logic_and()

        while self.match(OR):
            operator = self.previous()
            right = self.logic_and()
            expr = Logical(expr, operator, right)

        return expr

    def logic_and(self):
        """
        Syntax:
           logic_and := equality ( "and" equality )* ;
        """
        expr = self.equality()

        while self.match(AND):
            operator = self.previous()
            right = self.equality()
            expr = Logical(expr, operator, right)

        return expr

    def equality(self):
        """
        Syntax:
            equality := comparison ( ( "!=" | "==" ) comparison )* ;
        """
        expr = self.comparison()

        while self.match(BANG_EQUAL, EQUAL_EQUAL):
            operator = self.previous()
            right = self.comparison()
            expr = Binary(expr, operator, right)

        return expr

    def comparison(self):
        """
        Syntax:
            comparison := term ( ( ">" | ">=" | "<" | "<=" ) term )* ;
        """
        expr = self.term()

        while self.match(GREATER, GREATER_EQUAL, LESS, LESS_EQUAL):
            operator = self.previous()
            right = self.term()
            expr = Binary(expr, operator, right)

        return expr

    def term(self):
        """
        Syntax:
            term := factor ( ( "-" | "+" ) factor )* ;
        """
        expr = self.factor()

        while self.match(MINUS, PLUS):
            operator = self.previous()
            right = self.factor()
            expr = Binary(expr, operator, right)
        
        return expr

    def factor(self):
        """
        Syntax:
            factor := unary ( ( "/" | "*" ) unary )* ;
        """
        expr = self.unary()

        while self.match(SLASH, STAR):
            operator = self.previous()
            right = self.unary()
            expr = Binary(expr, operator, right)

        return expr

    def unary(self):
        """
        Syntax:
            unary := ( "!" | "-" ) unary 
                     | call ;
        """
        if self.match(BANG, MINUS):
            operator = self.previous()
            right = self.unary()
            return Unary(operator, right)
        
        return self.call()

    def call(self):
        """
        Syntax:
            call := primary ( "(" arguments? ")" | "." IDENTIFIER )* ;
        """
        expr = self.primary()

        while True:
            if self.match(LEFT_PAREN):
                expr = self.finishCall(expr)
            elif self.match(DOT):
                name = self.consume(IDENTIFIER, "Expect property name after '.'.")
                expr = Get(expr, name)
            else:
                break
        
        return expr

    def finishCall(self, callee: Expr):
        arguments = []
        if not self.check(RIGHT_PAREN):
            while True:
                if len(arguments) >= 255:
                    error(self.peek().line, "Can't have more than 255 arguments.")
                
                arguments.append(self.expression())
                
                if self.match(COMMA):
                    continue
                else:
                    break
        
        paren = self.consume(RIGHT_PAREN, "Expect ')' after arguments.")
        return Call(callee, paren, arguments)

    def primary(self):
        """
        Syntax:
            primary := "true" | "false" | "nil" | "this"
                       | NUMBER | STRING | IDENTIFIER | "(" expression ")"
                       | "super" "." IDENTIFIER ;
        """
        if self.match(FALSE): return Literal(False)
        if self.match(TRUE): return Literal(True)
        if self.match(NIL): return Literal(None)

        if self.match(NUMBER, STRING): return Literal(self.previous().literal)

        if self.match(SUPER):
            keyword = self.previous()
            self.consume(DOT, "Expect '.' after 'super'.")
            method = self.consume(IDENTIFIER, "Expect superclass method name.")
            return Super(keyword, method)
        
        if self.match(THIS):
            return This(self.previous())

        if self.match(IDENTIFIER):
            return Variable(self.previous())

        if self.match(LEFT_PAREN):
            expr = self.expression()
            self.consume(RIGHT_PAREN, "Expect ')' after expression.")
            return Grouping(expr)
        
        error(self.peek().line, "Expect expression.")        
    